# Generated by Django 2.2.27 on 2025-03-19 12:06
import os

from django.db import migrations

from app import models as app_models
from app.utils.s3_utils import (
    convert_task_path_to_s3,
    s3_object_exists,
)
from webodm import settings


ASSETS_MAP = {
    "all.zip": {"deferred_path": "all.zip", "deferred_compress_dir": "."},
    "orthophoto.tif": os.path.join("odm_orthophoto", "odm_orthophoto.tif"),
    "orthophoto.png": os.path.join("odm_orthophoto", "odm_orthophoto.png"),
    "orthophoto.mbtiles": os.path.join("odm_orthophoto", "odm_orthophoto.mbtiles"),
    "orthophoto.kmz": os.path.join("odm_orthophoto", "odm_orthophoto.kmz"),
    "georeferenced_model.las": os.path.join(
        "odm_georeferencing", "odm_georeferenced_model.las"
    ),
    "georeferenced_model.laz": os.path.join(
        "odm_georeferencing", "odm_georeferenced_model.laz"
    ),
    "georeferenced_model.ply": os.path.join(
        "odm_georeferencing", "odm_georeferenced_model.ply"
    ),
    "georeferenced_model.csv": os.path.join(
        "odm_georeferencing", "odm_georeferenced_model.csv"
    ),
    "textured_model.zip": {
        "deferred_path": "textured_model.zip",
        "deferred_compress_dir": "odm_texturing",
        "deferred_exclude_files": ("odm_textured_model_geo.glb",),
    },
    "textured_model.glb": os.path.join("odm_texturing", "odm_textured_model_geo.glb"),
    "3d_tiles_model.zip": {
        "deferred_path": "3d_tiles_model.zip",
        "deferred_compress_dir": os.path.join("3d_tiles", "model"),
    },
    "3d_tiles_pointcloud.zip": {
        "deferred_path": "3d_tiles_pointcloud.zip",
        "deferred_compress_dir": os.path.join("3d_tiles", "pointcloud"),
    },
    "dtm.tif": os.path.join("odm_dem", "dtm.tif"),
    "dsm.tif": os.path.join("odm_dem", "dsm.tif"),
    "dtm_tiles.zip": {
        "deferred_path": "dtm_tiles.zip",
        "deferred_compress_dir": "dtm_tiles",
    },
    "dsm_tiles.zip": {
        "deferred_path": "dsm_tiles.zip",
        "deferred_compress_dir": "dsm_tiles",
    },
    "orthophoto_tiles.zip": {
        "deferred_path": "orthophoto_tiles.zip",
        "deferred_compress_dir": "orthophoto_tiles",
    },
    "cameras.json": "cameras.json",
    "shots.geojson": os.path.join("odm_report", "shots.geojson"),
    "report.pdf": os.path.join("odm_report", "report.pdf"),
    "ground_control_points.geojson": os.path.join(
        "odm_georeferencing", "ground_control_points.geojson"
    ),
}


def asset_is_from_orthophoto(asset: str):
    simple_assets_dirs = [
        "fotos/",
        "videos/",
        "fotos_360/",
        "foto_giga/",
    ]

    for asset_dir in simple_assets_dirs:
        if asset.startswith(asset_dir):
            return False

    return True


def populate_available_assets(apps, schema_editor):
    Task = apps.get_model("app", "Task")

    for migration_task in Task.objects.all():
        project = app_models.Project()
        project.id = migration_task.project_id
        task = app_models.Task(id=migration_task.id, project=project)

        s3_assets = task.list_s3_available_assets()
        task.available_assets = [
            asset for asset in s3_assets if not asset_is_from_orthophoto(asset)
        ]
        update_available_assets_field(task)
        migration_task.available_assets = task.available_assets
        migration_task.save()


def update_available_assets_field(task):
    """
    Updates the available_assets field with the actual types of assets available
    :param commit: when True also saves the model, otherwise the user should manually call save()
    """
    all_assets = list(ASSETS_MAP.keys())

    # Obter os assets disponíveis atualmente
    current_available_assets = set(task.available_assets)

    # Verificar e adicionar novos assets disponíveis
    new_available_assets = [
        asset for asset in all_assets if is_asset_available_slow(task, asset)
    ]

    # Atualizar a lista de available_assets com novos assets
    updated_available_assets = current_available_assets.union(new_available_assets)
    task.available_assets = list(updated_available_assets)


def is_asset_available_slow(task, asset):
    if asset in ASSETS_MAP:
        value = ASSETS_MAP[asset]
        if isinstance(value, str):
            if asset_exists_on_s3(assets_path(task, value)):
                return True
        elif isinstance(value, dict):
            if "deferred_compress_dir" in value:
                if asset_exists_on_s3(
                    assets_path(task, value["deferred_compress_dir"])
                ):
                    return True

    # Additional checks for 'foto360.jpg' and files in 'fotos' or 'videos' directories
    if asset == "foto360.jpg":
        return asset_exists_on_s3(assets_path(task, "foto360.jpg"))
    if (
        asset.startswith("fotos/")
        or asset.startswith("videos/")
        or asset.startswith("foto_giga/")
    ):
        return asset_exists_on_s3(assets_path(task, asset))

    return False


def assets_path(task, *args):
    return os.path.join(
        settings.MEDIA_ROOT,
        assets_directory_path(task.id, task.project.id, ""),
        "assets",
        *args,
    )


def assets_directory_path(taskId, projectId, filename):
    return "{0}{1}".format(task_directory_path(taskId, projectId), filename)


def task_directory_path(taskId, projectId):
    return "{0}/{1}/".format(projectId, taskId)


def asset_exists_on_s3(asset_path: str):
    s3_key = convert_task_path_to_s3(asset_path)
    return s3_object_exists(s3_key)


def empty_func(apps, schema_editor):
    pass


class Migration(migrations.Migration):

    dependencies = [
        ("app", "0048_available_assets_from_s3"),
    ]

    operations = [migrations.RunPython(populate_available_assets, empty_func)]
