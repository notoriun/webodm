# Generated by Django 2.2.27 on 2025-03-24 03:36

from django.db import migrations, models
from PIL import Image
from PIL.ExifTags import TAGS, GPSTAGS
from webodm import settings
from app.classes.task_assets_manager import TaskAssetsManager
import django.db.models.deletion
import django.utils.timezone
import uuid
import os
import ffmpeg
import re


ASSET_TYPE_FOTO = 1
ASSET_TYPE_ORTHOPHOTO = 2
ASSET_TYPE_VIDEO = 3
ASSET_TYPE_FOTO_360 = 4
ASSET_TYPE_FOTO_360_THUMB = 5
ASSET_TYPE_FOTO_GIGA = 6

ASSETS_MAP = {
    "all.zip": {"deferred_path": "all.zip", "deferred_compress_dir": "."},
    "orthophoto.tif": os.path.join("odm_orthophoto", "odm_orthophoto.tif"),
    "orthophoto.png": os.path.join("odm_orthophoto", "odm_orthophoto.png"),
    "orthophoto.mbtiles": os.path.join("odm_orthophoto", "odm_orthophoto.mbtiles"),
    "orthophoto.kmz": os.path.join("odm_orthophoto", "odm_orthophoto.kmz"),
    "georeferenced_model.las": os.path.join(
        "odm_georeferencing", "odm_georeferenced_model.las"
    ),
    "georeferenced_model.laz": os.path.join(
        "odm_georeferencing", "odm_georeferenced_model.laz"
    ),
    "georeferenced_model.ply": os.path.join(
        "odm_georeferencing", "odm_georeferenced_model.ply"
    ),
    "georeferenced_model.csv": os.path.join(
        "odm_georeferencing", "odm_georeferenced_model.csv"
    ),
    "textured_model.zip": {
        "deferred_path": "textured_model.zip",
        "deferred_compress_dir": "odm_texturing",
        "deferred_exclude_files": ("odm_textured_model_geo.glb",),
    },
    "textured_model.glb": os.path.join("odm_texturing", "odm_textured_model_geo.glb"),
    "3d_tiles_model.zip": {
        "deferred_path": "3d_tiles_model.zip",
        "deferred_compress_dir": os.path.join("3d_tiles", "model"),
    },
    "3d_tiles_pointcloud.zip": {
        "deferred_path": "3d_tiles_pointcloud.zip",
        "deferred_compress_dir": os.path.join("3d_tiles", "pointcloud"),
    },
    "dtm.tif": os.path.join("odm_dem", "dtm.tif"),
    "dsm.tif": os.path.join("odm_dem", "dsm.tif"),
    "dtm_tiles.zip": {
        "deferred_path": "dtm_tiles.zip",
        "deferred_compress_dir": "dtm_tiles",
    },
    "dsm_tiles.zip": {
        "deferred_path": "dsm_tiles.zip",
        "deferred_compress_dir": "dsm_tiles",
    },
    "orthophoto_tiles.zip": {
        "deferred_path": "orthophoto_tiles.zip",
        "deferred_compress_dir": "orthophoto_tiles",
    },
    "cameras.json": "cameras.json",
    "shots.geojson": os.path.join("odm_report", "shots.geojson"),
    "report.pdf": os.path.join("odm_report", "report.pdf"),
    "ground_control_points.geojson": os.path.join(
        "odm_georeferencing", "ground_control_points.geojson"
    ),
}


def populate_task_assets(apps, schema_editor):
    Task = apps.get_model("app", "Task")
    TaskAsset = apps.get_model("app", "TaskAsset")

    for task in Task.objects.all():
        assets_manager = TaskAssetsManager(task)
        new_task_assets = []

        for asset in task.available_assets:
            if asset in [
                "fotos/metadata.json",
                "fotos_360/metadata.json",
                "videos/metadata.json",
            ]:
                continue

            try:
                asset_type = get_asset_type(asset)
                asset_downloaded_path = download_asset(asset, task, assets_manager)
            except Exception as e:
                print(
                    f"Error on process a asset ({asset}) of {task}. Original error: {str(e)}"
                )
                continue

            asset_location = get_asset_gps(asset_downloaded_path, asset_type)

            new_task_assets.append(
                TaskAsset(
                    type=asset_type,
                    name=asset,
                    task=task,
                    status=2,
                    latitude=asset_location[0],
                    longitude=asset_location[1],
                    altitude=asset_location[2],
                )
            )

            try:
                os.remove(asset_downloaded_path)
            except:
                pass

        TaskAsset.objects.bulk_create(new_task_assets)


def get_asset_type(asset: str):
    if asset.startswith("fotos/"):
        return ASSET_TYPE_FOTO
    elif asset.startswith("fotos_360/"):
        return (
            ASSET_TYPE_FOTO_360_THUMB
            if asset.endswith("_thumb.jpg")
            else ASSET_TYPE_FOTO_360
        )
    elif asset.startswith("videos/"):
        return ASSET_TYPE_VIDEO
    elif asset.startswith("foto_giga/"):
        return ASSET_TYPE_FOTO_GIGA
    else:
        return ASSET_TYPE_ORTHOPHOTO


def assets_path(task, *args):
    return os.path.join(
        settings.MEDIA_ROOT,
        assets_directory_path(task.id, task.project.id, ""),
        "assets",
        *args,
    )


def assets_directory_path(taskId, projectId, filename):
    return "{0}{1}".format(task_directory_path(taskId, projectId), filename)


def task_directory_path(taskId, projectId):
    return "{0}/{1}/".format(projectId, taskId)


def get_asset_gps(asset: str, asset_type: int):
    try:
        if asset_type == ASSET_TYPE_FOTO_GIGA:
            return None, None, None
        elif asset_type == ASSET_TYPE_VIDEO:
            return get_video_gps(asset)
        else:
            return get_image_gps(asset)
    except Exception as e:
        print(
            f"Warning cannot get location of asset ({asset}), setting null. Original error: {str(e)}"
        )
        return None, None, None


def get_video_gps(file_path: str):
    try:
        probe = ffmpeg.probe(file_path)
        tags = probe.get("format", {}).get("tags", {})
        location = tags.get("location")
        if location:
            # Remove a barra no final da string, se houver
            location = location.rstrip("/")

            # Definir a expressão regular para capturar latitude e longitude
            match = re.match(r"([+-]?\d+\.\d+),?\s*([+-]?\d+\.\d+)", location)
            if not match:
                raise ValueError("Formato inválido para a string de localização")

            # Extrair latitude e longitude da correspondência
            lat_str, lon_str = match.groups()

            # Converter para float
            latitude = float(lat_str)
            longitude = float(lon_str)
            return latitude, longitude, None
    except ffmpeg.Error as e:
        print(e)
        return None, None, None
    return None, None, None


def get_image_gps(file_path: str):
    image = Image.open(file_path)
    exif_data = get_exif_data(image)
    return get_lat_lon_alt(exif_data)


def get_exif_data(image):
    exif_data = {}
    info = image._getexif()
    if info:
        for tag, value in info.items():
            decoded = TAGS.get(tag, tag)
            if decoded == "GPSInfo":
                gps_data = {}
                for t in value:
                    sub_decoded = GPSTAGS.get(t, t)
                    gps_data[sub_decoded] = value[t]
                exif_data[decoded] = gps_data
            else:
                exif_data[decoded] = value

    return exif_data


def get_lat_lon_alt(exif_data):
    gps_info = exif_data.get("GPSInfo")
    if not gps_info:
        return None, None, None

    def get_if_exist(data, key):
        return data[key] if key in data else None

    lat = get_if_exist(gps_info, GPSTAGS.get(2))  # GPSLatitude
    lat_ref = get_if_exist(gps_info, GPSTAGS.get(1))  # GPSLatitudeRef
    lon = get_if_exist(gps_info, GPSTAGS.get(4))  # GPSLongitude
    lon_ref = get_if_exist(gps_info, GPSTAGS.get(3))  # GPSLongitudeRef
    alt = get_if_exist(gps_info, GPSTAGS.get(6))  # GPSAltitude
    alt_ref = get_if_exist(gps_info, GPSTAGS.get(5))  # GPSAltitudeRef

    if lat and lon and lat_ref and lon_ref:
        lat = convert_to_degrees(lat, lat_ref)
        lon = convert_to_degrees(lon, lon_ref)

        if alt:
            alt = float(alt)
            if alt_ref and alt_ref != 0:
                alt = -alt

        return lat, lon, alt
    return None, None, None


def convert_to_degrees(value, ref):
    def to_degrees(val):
        d = float(val[0])
        m = float(val[1])
        s = float(val[2])
        return d + (m / 60.0) + (s / 3600.0)

    degrees = to_degrees(value)
    if ref in ["S", "W"]:
        degrees = -degrees
    return degrees


def download_asset(asset: str, task, assets_manager):
    asset_path = get_asset_local_path(task, asset)

    if os.path.exists(asset_path):
        return asset_path

    return assets_manager.download_asset_to_temp(asset_path)


def get_asset_local_path(task, asset):
    if asset in ASSETS_MAP:
        value = ASSETS_MAP[asset]
        if isinstance(value, str):
            return assets_path(task, value)

        elif isinstance(value, dict):
            if "deferred_path" in value and "deferred_compress_dir" in value:
                return value["deferred_path"]

    return assets_path(task, asset)


def populate_available_assets(apps, schema_editor):
    Task = apps.get_model("app", "Task")
    TaskAsset = apps.get_model("app", "TaskAsset")

    for task_asset in TaskAsset.objects.all():
        task = Task.objects.get(pk=task_asset.task_id)
        task.available_assets.append(task_asset.name)
        task.save(update_fields=("available_assets",))


class Migration(migrations.Migration):

    dependencies = [
        ("app", "0050_task_node_error_retry"),
    ]

    operations = [
        migrations.CreateModel(
            name="TaskAsset",
            fields=[
                (
                    "id",
                    models.UUIDField(
                        default=uuid.uuid4,
                        editable=False,
                        primary_key=True,
                        serialize=False,
                        unique=True,
                        verbose_name="Id",
                    ),
                ),
                (
                    "type",
                    models.IntegerField(
                        choices=[
                            (1, "FOTO"),
                            (4, "FOTO_360"),
                            (6, "FOTO_GIGA"),
                            (2, "ORTHOPHOTO"),
                            (3, "VIDEO"),
                        ],
                        db_index=True,
                        help_text="The type of asset.",
                        verbose_name="Type of asset",
                    ),
                ),
                (
                    "name",
                    models.CharField(
                        blank=True,
                        help_text="The task filename",
                        max_length=255,
                        null=True,
                        verbose_name="Name",
                    ),
                ),
                (
                    "created_at",
                    models.DateTimeField(
                        default=django.utils.timezone.now,
                        help_text="Creation date",
                        verbose_name="Created at",
                    ),
                ),
                (
                    "status",
                    models.IntegerField(
                        choices=[
                            (1, "FOTO"),
                            (4, "FOTO_360"),
                            (6, "FOTO_GIGA"),
                            (2, "ORTHOPHOTO"),
                            (3, "VIDEO"),
                        ],
                        db_index=True,
                        help_text="Current status of asset.",
                        verbose_name="Status of asset",
                    ),
                ),
                (
                    "latitude",
                    models.FloatField(
                        blank=True,
                        default=None,
                        help_text="Latitude",
                        null=True,
                        verbose_name="Latitude",
                    ),
                ),
                (
                    "longitude",
                    models.FloatField(
                        blank=True,
                        default=None,
                        help_text="Longitude",
                        null=True,
                        verbose_name="Longitude",
                    ),
                ),
                (
                    "altitude",
                    models.FloatField(
                        blank=True,
                        default=None,
                        help_text="Altitude",
                        null=True,
                        verbose_name="Altitude",
                    ),
                ),
                (
                    "task",
                    models.ForeignKey(
                        help_text="The task of this asset",
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="assets",
                        to="app.Task",
                        verbose_name="Task",
                    ),
                ),
            ],
            options={
                "verbose_name": "Asset Task",
                "verbose_name_plural": "Asset Tasks",
            },
        ),
        migrations.RunPython(populate_task_assets, populate_available_assets),
        migrations.RemoveField(
            model_name="task",
            name="available_assets",
        ),
    ]
